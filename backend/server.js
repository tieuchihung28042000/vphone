const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
require('dotenv').config();

const Inventory = require('./models/Inventory');
const Cashbook = require('./models/Cashbook'); // TH√äM D√íNG N√ÄY
const ExportHistory = require('./models/ExportHistory'); // TH√äM MODEL EXPORT HISTORY
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/user');
const reportRoutes = require('./routes/report');
const branchRoutes = require('./routes/branch');
const categoryRoutes = require('./routes/category');
const congNoRoutes = require('./routes/congno');
const adminRoutes = require('./routes/admin');
const cashbookRoutes = require('./routes/cashbook'); // TH√äM D√íNG N√ÄY

const app = express();

// Danh s√°ch origin frontend ƒë∆∞·ª£c ph√©p truy c·∫≠p API backend
const allowedOrigins = [
  'http://localhost:5174',
  'http://localhost:5175',
  'http://localhost:3000',
  'http://localhost:8080',
  'http://localhost:80',
  'https://chinhthuc-jade.vercel.app',
  'http://app.vphone.vn',
  'https://app.vphone.vn',
  'http://103.109.187.224',
  'https://103.109.187.224',
];

app.use(cors({
  origin: function(origin, callback) {
    // Cho ph√©p c√°c request kh√¥ng c√≥ origin (Postman, mobile apps)
    if (!origin) return callback(null, true);
    
    // Ki·ªÉm tra n·∫øu origin trong danh s√°ch cho ph√©p
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    
    // Cho ph√©p IP addresses trong production (VPS)
    if (origin && origin.match(/^https?:\/\/\d+\.\d+\.\d+\.\d+(:\d+)?$/)) {
      console.log('‚úÖ CORS cho ph√©p IP:', origin);
      return callback(null, true);
    }
    
    // Trong development, cho ph√©p t·∫•t c·∫£ origins
    if (process.env.NODE_ENV !== 'production') {
      console.log('‚ö†Ô∏è CORS dev mode - allowing origin:', origin);
      return callback(null, true);
    }
    
    console.log('‚ùå CORS b·ªã ch·∫∑n origin:', origin);
    const msg = '‚ùå CORS b·ªã ch·∫∑n: ' + origin;
    return callback(new Error(msg), false);
  },
  credentials: true,
}));

app.options('*', cors());
app.use(express.json());

// ==== ƒêƒÉng k√Ω c√°c route API ====
app.use('/api', adminRoutes);
app.use('/api', reportRoutes); // ƒê√É S·ª¨A, ƒë·∫∑t ƒë√∫ng path
app.use('/api/auth', authRoutes);
app.use('/api/user', userRoutes);
app.use('/api/branches', branchRoutes);
app.use('/api/categories', categoryRoutes);
app.use('/api/cong-no', congNoRoutes);
app.use('/api/cashbook', cashbookRoutes); // ROUTE S·ªî QU·ª∏

// ==================== API: SUPER DEBUG BACKEND ====================
app.get('/api/super-debug/:id', async (req, res) => {
  try {
    const id = req.params.id;
    console.log('üîç BACKEND SUPER DEBUG for ID:', id);
    
    // Test trong Inventory
    const inventoryItem = await Inventory.findById(id);
    console.log('üì¶ Backend Inventory result:', inventoryItem ? {
      _id: inventoryItem._id,
      product_name: inventoryItem.product_name,
      status: inventoryItem.status,
      price_sell: inventoryItem.price_sell,
      giaBan: inventoryItem.giaBan
    } : 'NOT FOUND');
    
    // Test trong ExportHistory  
    let exportItem = null;
    try {
      exportItem = await ExportHistory.findById(id);
      console.log('üìã Backend ExportHistory result:', exportItem ? {
        _id: exportItem._id,
        product_name: exportItem.product_name,
        price_sell: exportItem.price_sell
      } : 'NOT FOUND');
    } catch (err) {
      console.log('üìã ExportHistory model error:', err.message);
    }
    
    // ƒê·∫øm records
    const inventoryCount = await Inventory.countDocuments();
    const soldCount = await Inventory.countDocuments({ status: 'sold' });
    
    res.status(200).json({
      message: 'üîç BACKEND SUPER DEBUG RESULTS',
      test_id: id,
      inventory_item: inventoryItem ? {
        found: true,
        _id: inventoryItem._id,
        product_name: inventoryItem.product_name,
        status: inventoryItem.status,
        price_sell: inventoryItem.price_sell,
        giaBan: inventoryItem.giaBan
      } : { found: false },
      export_history_item: exportItem ? {
        found: true,
        _id: exportItem._id,
        product_name: exportItem.product_name,
        price_sell: exportItem.price_sell
      } : { found: false },
      collections_stats: {
        total_inventory: inventoryCount,
        inventory_sold: soldCount
      }
    });
  } catch (error) {
    console.error('‚ùå Backend super debug error:', error);
    res.status(500).json({ message: '‚ùå Backend super debug failed', error: error.message });
  }
});

// ==================== API: SIMPLE UPDATE TEST ====================
app.put('/api/test-update/:id', async (req, res) => {
  try {
    console.log('üß™ SIMPLE UPDATE TEST for ID:', req.params.id);
    console.log('üß™ Request body:', req.body);
    
    // ƒê∆°n gi·∫£n: ch·ªâ update 1 field
    const updated = await Inventory.findByIdAndUpdate(
      req.params.id,
      { $set: { note: 'TEST UPDATE WORKED', updatedAt: new Date() } },
      { new: true }
    );
    
    if (!updated) {
      return res.status(404).json({ message: '‚ùå Test update failed - record not found' });
    }
    
    res.status(200).json({
      message: '‚úÖ TEST UPDATE SUCCESS!',
      updated_fields: {
        _id: updated._id,
        note: updated.note,
        product_name: updated.product_name,
        status: updated.status
      }
    });
  } catch (error) {
    console.error('‚ùå Test update error:', error);
    res.status(500).json({ message: '‚ùå Test update failed', error: error.message });
  }
});

// API l·∫•y danh s√°ch nh·∫≠p h√†ng
app.get('/api/nhap-hang', async (req, res) => {
  try {
    const items = await Inventory.find().sort({ import_date: -1, _id: -1 });
    res.status(200).json({ items });
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y danh s√°ch nh·∫≠p h√†ng:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi l·∫•y danh s√°ch', error: error.message });
  }
});

// API nh·∫≠p h√†ng (t√≠ch h·ª£p ghi s·ªï qu·ªπ)
app.post('/api/nhap-hang', async (req, res) => {
  try {
    const {
      imei,
      sku,
      price_import,
      product_name,
      import_date,
      supplier,
      branch,
      note,
      quantity,
      category,
      source, // Ngu·ªìn ti·ªÅn: Ti·ªÅn m·∫∑t/Th·∫ª/C√¥ng n·ª£ (t·ª´ frontend)
      da_thanh_toan_nhap // S·ªë ti·ªÅn ƒë√£ thanh to√°n cho nh√† cung c·∫•p
    } = req.body;

    if (imei) {
      const exists = await Inventory.findOne({ imei });
      if (exists) {
        return res.status(400).json({ message: '‚ùå IMEI n√†y ƒë√£ t·ªìn t·∫°i trong kho.' });
      }
      // T√≠nh to√°n ƒë√£ thanh to√°n
      const daTTNhapNum = Number(da_thanh_toan_nhap) || 0;
      
      const newItem = new Inventory({
        imei,
        sku,
        price_import,
        product_name,
        tenSanPham: product_name,
        import_date,
        supplier,
        branch,
        note,
        quantity: 1,
        category,
        da_thanh_toan_nhap: daTTNhapNum, // ƒê√£ thanh to√°n cho nh√† cung c·∫•p
      });
      await newItem.save();

      // --- Ghi S·ªî QU·ª∏: ch·ªâ ghi s·ªë ti·ªÅn ƒë√£ thanh to√°n th·ª±c t·∫ø ---
      if (daTTNhapNum > 0) {
        await Cashbook.create({
          type: 'chi',
          amount: daTTNhapNum,
          content: `Nh·∫≠p h√†ng: ${product_name} (IMEI: ${imei})`,
          note: note || '',
          date: import_date || new Date(),
          branch,
          source: source || 'Ti·ªÅn m·∫∑t',
          supplier: supplier || '',
          related_id: newItem._id,
        });
      }

      return res.status(201).json({
        message: '‚úÖ Nh·∫≠p h√†ng th√†nh c√¥ng!',
        item: newItem,
      });
    }

    if (!sku || !product_name) {
      return res.status(400).json({ message: '‚ùå Thi·∫øu SKU ho·∫∑c t√™n s·∫£n ph·∫©m.' });
    }

    let existItem = await Inventory.findOne({
      $or: [{ imei: null }, { imei: "" }, { imei: undefined }],
      sku: sku,
      branch: branch,
      product_name: product_name,
      price_import: price_import,
      category: category,
    });

    if (existItem) {
      // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng
      const daTTNhapNum = Number(da_thanh_toan_nhap) || 0;
      
      existItem.quantity = (existItem.quantity || 1) + Number(quantity || 1);
      existItem.import_date = import_date || existItem.import_date;
      existItem.supplier = supplier || existItem.supplier;
      existItem.note = note || existItem.note;
      existItem.da_thanh_toan_nhap = (existItem.da_thanh_toan_nhap || 0) + daTTNhapNum;
      await existItem.save();
      return res.status(200).json({
        message: '‚úÖ ƒê√£ c·ªông d·ªìn s·ªë l∆∞·ª£ng ph·ª• ki·ªán!',
        item: existItem,
      });
    } else {
      // T√≠nh to√°n cho ph·ª• ki·ªán m·ªõi
      const daTTNhapNum = Number(da_thanh_toan_nhap) || 0;
      const quantityNum = Number(quantity || 1);
      
      const newItem = new Inventory({
        sku,
        price_import,
        product_name,
        tenSanPham: product_name,
        import_date,
        supplier,
        branch,
        note,
        quantity: quantityNum,
        category,
        da_thanh_toan_nhap: daTTNhapNum, // ƒê√£ thanh to√°n cho nh√† cung c·∫•p
      });
      await newItem.save();

      // --- Ghi S·ªî QU·ª∏: ch·ªâ ghi s·ªë ti·ªÅn ƒë√£ thanh to√°n th·ª±c t·∫ø ---
      if (daTTNhapNum > 0) {
        await Cashbook.create({
          type: 'chi',
          amount: daTTNhapNum,
          content: `Nh·∫≠p ph·ª• ki·ªán: ${product_name}`,
          note: note || '',
          date: import_date || new Date(),
          branch,
          source: source || 'Ti·ªÅn m·∫∑t',
          supplier: supplier || '',
          related_id: newItem._id,
        });
      }

      return res.status(201).json({
        message: '‚úÖ Nh·∫≠p ph·ª• ki·ªán th√†nh c√¥ng!',
        item: newItem,
      });
    }
  } catch (error) {
    console.error('‚ùå L·ªói khi nh·∫≠p h√†ng:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi nh·∫≠p h√†ng', error: error.message });
  }
});

// API s·ª≠a h√†ng
app.put('/api/nhap-hang/:id', async (req, res) => {
  try {
    const updatedItem = await Inventory.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true },
    );

    if (!updatedItem) {
      return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ƒë·ªÉ c·∫≠p nh·∫≠t.' });
    }

    res.status(200).json({
      message: '‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng!',
      item: updatedItem,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi c·∫≠p nh·∫≠t s·∫£n ph·∫©m:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi c·∫≠p nh·∫≠t', error: error.message });
  }
});

// API xo√° h√†ng
app.delete('/api/nhap-hang/:id', async (req, res) => {
  try {
    const deletedItem = await Inventory.findByIdAndDelete(req.params.id);

    if (!deletedItem) {
      return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ƒë·ªÉ xo√°.' });
    }

    res.status(200).json({
      message: '‚úÖ ƒê√£ xo√° th√†nh c√¥ng!',
      item: deletedItem,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi xo√° s·∫£n ph·∫©m:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi xo√° s·∫£n ph·∫©m', error: error.message });
  }
});

// API xu·∫•t h√†ng (t√≠ch h·ª£p ghi s·ªï qu·ªπ)
app.post('/api/xuat-hang', async (req, res) => {
  try {
    const {
      imei,
      price_sell,
      customer_name,
      customer_phone,
      warranty,
      note,
      sku,
      product_name,
      sold_date,
      // debt, // ‚úÖ REMOVED: Kh√¥ng d√πng field debt n·ªØa
      da_thanh_toan, // S·ªë ti·ªÅn ƒë√£ thanh to√°n
      branch,
      source, // Ngu·ªìn ti·ªÅn (frontend truy·ªÅn l√™n)
      is_accessory,
      quantity // S·ªë l∆∞·ª£ng (cho ph·ª• ki·ªán)
    } = req.body;

    let item;
    
    // ‚úÖ X·ª≠ l√Ω ph·ª• ki·ªán v√† s·∫£n ph·∫©m c√≥ IMEI kh√°c nhau
    if (is_accessory || !imei) {
      // Ph·ª• ki·ªán: t√¨m theo SKU v√† product_name, status in_stock
      const query = {
        status: 'in_stock',
        $or: [
          { sku: sku },
          { product_name: product_name },
          { tenSanPham: product_name }
        ]
      };
      
      const availableItems = await Inventory.find(query);
      
      if (availableItems.length === 0) {
        return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y ph·ª• ki·ªán trong kho.' });
      }
      
      // L·∫•y item ƒë·∫ßu ti√™n c√≥ s·ªë l∆∞·ª£ng > 0
      item = availableItems.find(i => (i.quantity || 0) > 0) || availableItems[0];
      
      if (!item) {
        return res.status(404).json({ message: '‚ùå Ph·ª• ki·ªán ƒë√£ h·∫øt h√†ng.' });
      }
      
      // Ki·ªÉm tra s·ªë l∆∞·ª£ng
      const currentQuantity = item.quantity || 0;
      const sellQuantity = parseInt(quantity) || 1;
      
      if (currentQuantity < sellQuantity) {
        return res.status(400).json({ 
          message: `‚ùå Kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng. C√≤n l·∫°i: ${currentQuantity}, y√™u c·∫ßu: ${sellQuantity}` 
        });
      }
      
    } else {
      // S·∫£n ph·∫©m c√≥ IMEI: t√¨m theo IMEI
      item = await Inventory.findOne({ imei });
      if (!item) {
        return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y IMEI trong kho.' });
      }

      if (item.status === 'sold') {
        return res.status(400).json({ message: '‚ö†Ô∏è M√°y n√†y ƒë√£ ƒë∆∞·ª£c b√°n tr∆∞·ªõc ƒë√≥.' });
      }
    }

    // ‚úÖ X·ª≠ l√Ω kh√°c nhau cho ph·ª• ki·ªán v√† s·∫£n ph·∫©m IMEI
    if (is_accessory || !imei) {
      // Ph·ª• ki·ªán: gi·∫£m s·ªë l∆∞·ª£ng, kh√¥ng ƒë·ªïi status
      const sellQuantity = parseInt(quantity) || 1;
      item.quantity = (item.quantity || 0) - sellQuantity;
      
      // N·∫øu h·∫øt h√†ng th√¨ chuy·ªÉn status
      if (item.quantity <= 0) {
        item.status = 'sold';
        item.quantity = 0;
      }
      
      // ‚úÖ Ghi v√†o ExportHistory thay v√¨ Inventory
      const priceSellNum = Number(price_sell) || 0;
      const daTTNum = Number(da_thanh_toan) || 0;
      // ‚úÖ REMOVED: autoDebt kh√¥ng c·∫ßn thi·∫øt n·ªØa
      
      const soldAccessory = new ExportHistory({
        imei: '', // Ph·ª• ki·ªán kh√¥ng c√≥ IMEI
        sku: item.sku,
        product_name: item.product_name,
        tenSanPham: item.tenSanPham,
        category: item.category,
        price_import: item.price_import,
        giaBan: price_sell,
        price_sell: price_sell,
        da_thanh_toan: daTTNum, // S·ªë ti·ªÅn ƒë√£ thanh to√°n
        // ‚úÖ REMOVED: debt field - t√≠nh c√¥ng n·ª£ b·∫±ng price_sell - da_thanh_toan
        sold_date: sold_date ? new Date(sold_date) : new Date(),
        customer_name: customer_name || '',
        customer_phone: customer_phone || '',
        warranty: warranty || '',
        note: note || '',
        branch: branch || item.branch,
        source: source || 'tien_mat',
        status: 'sold',
        quantity: sellQuantity,
        is_accessory: true
      });
      
      await soldAccessory.save();
      await item.save();
      
      // ƒê·∫∑t item th√†nh soldAccessory ƒë·ªÉ ghi s·ªï qu·ªπ
      item = soldAccessory;
      
    } else {
      // ‚úÖ S·∫£n ph·∫©m IMEI: T·∫°o record m·ªõi trong ExportHistory + c·∫≠p nh·∫≠t Inventory
      
      // 1. C·∫≠p nh·∫≠t Inventory (chuy·ªÉn status sang sold)
      item.status = 'sold';
      item.sold_date = sold_date ? new Date(sold_date) : new Date();
      await item.save();
      
      // 2. T·∫°o record m·ªõi trong ExportHistory
      const priceSellNum = Number(price_sell) || 0;
      const daTTNum = Number(da_thanh_toan) || 0;
      // ‚úÖ REMOVED: autoDebt kh√¥ng c·∫ßn thi·∫øt n·ªØa
      
      const soldItem = new ExportHistory({
        imei: item.imei,
        sku: sku || item.sku,
        product_name: product_name || item.product_name,
        category: item.category,
        price_import: item.price_import,
        price_sell: price_sell,
        da_thanh_toan: daTTNum, // S·ªë ti·ªÅn ƒë√£ thanh to√°n
        // ‚úÖ REMOVED: debt field - t√≠nh c√¥ng n·ª£ b·∫±ng price_sell - da_thanh_toan
        sold_date: sold_date ? new Date(sold_date) : new Date(),
        customer_name: customer_name || '',
        customer_phone: customer_phone || '',
        warranty: warranty || '',
        note: note || '',
        branch: branch || item.branch,
        export_type: 'normal'
      });
      
      await soldItem.save();
      
      // C·∫≠p nh·∫≠t item ƒë·ªÉ s·ª≠ d·ª•ng cho ph·∫ßn ghi s·ªï qu·ªπ ph√≠a d∆∞·ªõi
      item = soldItem;
    }

    const profit = (item.giaBan || 0) - (item.price_import || 0);

    // --- Ghi S·ªî QU·ª∏: THU TI·ªÄN ---
    const productDescription = item.imei 
      ? `${item.product_name} (IMEI: ${item.imei})`
      : `${item.product_name} (Ph·ª• ki·ªán - SL: ${item.quantity || 1})`;
      
    // Ghi s·ªï qu·ªπ v·ªõi s·ªë ti·ªÅn ƒë√£ thanh to√°n th·ª±c t·∫ø
    const amountReceived = Number(item.da_thanh_toan || da_thanh_toan || 0);
    if (amountReceived > 0) {
      await Cashbook.create({
        type: 'thu',
        amount: amountReceived,
        content: `B√°n h√†ng: ${productDescription}`,
        note: note || '',
        date: sold_date || new Date(),
        branch: branch || '',
        source: source || 'Ti·ªÅn m·∫∑t',
        customer: customer_name || '',
        related_id: item._id
      });
    }

    // ‚úÖ REMOVED: Kh√¥ng d√πng field debt n·ªØa, t√≠nh c√¥ng n·ª£ b·∫±ng price_sell - da_thanh_toan
    // N·∫øu c√≥ c√¥ng n·ª£ th√¨ ghi s·ªï c√¥ng n·ª£ kh√°ch
    const congNo = Math.max((item.price_sell || 0) - (item.da_thanh_toan || 0), 0);
    if (congNo > 0) {
      await Cashbook.create({
        type: 'thu',
        amount: congNo,
        content: `C√¥ng n·ª£ kh√°ch h√†ng khi b√°n: ${productDescription}`,
        note: `C√¥ng n·ª£ kh√°ch: ${customer_name}`,
        date: sold_date || new Date(),
        branch: branch || '',
        source: 'C√¥ng n·ª£',
        customer: customer_name || '',
        related_id: item._id
      });
    }

    res.status(200).json({ message: '‚úÖ Xu·∫•t h√†ng th√†nh c√¥ng!', item, profit });
  } catch (error) {
    console.error('‚ùå L·ªói khi xu·∫•t h√†ng:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi xu·∫•t h√†ng', error: error.message });
  }
});

// API chi ti·∫øt IMEI
app.get('/api/imei-detail/:imei', async (req, res) => {
  try {
    const { imei } = req.params;
    const item = await Inventory.findOne({ imei });
    
    if (!item) {
      return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y IMEI n√†y' });
    }

    res.status(200).json({
      message: '‚úÖ Th√¥ng tin chi ti·∫øt IMEI',
      item
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y chi ti·∫øt IMEI:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi l·∫•y chi ti·∫øt IMEI', error: error.message });
  }
});

// API t·ªìn kho
app.get('/api/ton-kho', async (req, res) => {
  try {
    const items = await Inventory.find({ status: 'in_stock' });

    res.status(200).json({
      message: '‚úÖ Danh s√°ch m√°y c√≤n t·ªìn kho',
      total: items.length,
      items,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y t·ªìn kho:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi l·∫•y t·ªìn kho', error: error.message });
  }
});

// API c·∫£nh b√°o t·ªìn kho
app.get('/api/canh-bao-ton-kho', async (req, res) => {
  try {
    const items = await Inventory.find({ status: 'in_stock' });

    const grouped = {};
    items.forEach((item) => {
      const key = item.sku + (item.branch || '');
      if (!grouped[key]) {
        grouped[key] = {
          sku: item.sku || 'Kh√¥ng r√µ',
          tenSanPham: item.tenSanPham || item.product_name || 'Kh√¥ng r√µ',
          branch: item.branch || 'M·∫∑c ƒë·ªãnh',
          totalImport: 0,
          imeis: [],
        };
      }

      grouped[key].totalImport += 1;
      grouped[key].imeis.push(item.imei);
    });

    const result = Object.values(grouped)
      .map((g) => ({
        ...g,
        totalRemain: g.imeis.length,
      }))
      .filter((g) => g.totalRemain < 2);

    res.status(200).json({
      message: '‚úÖ Danh s√°ch h√†ng t·ªìn kho th·∫•p (d∆∞·ªõi 2)',
      total: result.length,
      items: result,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y danh s√°ch c·∫£nh b√°o t·ªìn kho:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi x·ª≠ l√Ω c·∫£nh b√°o t·ªìn kho', error: error.message });
  }
});

// API danh s√°ch xu·∫•t h√†ng  
app.get('/api/xuat-hang-list', async (req, res) => {
  try {
    // ‚úÖ L·∫•y t·ª´ ExportHistory thay v√¨ Inventory (v√¨ d·ªØ li·ªáu th·ª±c t·∫ø ·ªü ƒë√¢y)
    const rawItems = await ExportHistory.find({})
      .sort({ 
        sold_date: -1,      // ∆Øu ti√™n theo ng√†y b√°n (m·ªõi nh·∫•t tr∆∞·ªõc)
        export_date: -1,    // Ho·∫∑c export_date
        updated_at: -1,     // N·∫øu kh√¥ng c√≥ sold_date th√¨ theo updated_at  
        created_at: -1      // Cu·ªëi c√πng theo created_at
      });
    
    console.log(`‚úÖ Found ${rawItems.length} export records from ExportHistory (including accessories)`);
    
    // Debug: Log m·ªôt sample ƒë·ªÉ check field (ch·ªâ trong development)
    if (rawItems.length > 0 && process.env.NODE_ENV === 'development') {
      console.log('Sample export record fields:', {
        product_name: rawItems[0].product_name,
        imei: rawItems[0].imei || 'No IMEI (accessory)',
        sale_price: rawItems[0].sale_price,
        selling_price: rawItems[0].selling_price,
        customer_name: rawItems[0].customer_name,
        customer_phone: rawItems[0].customer_phone,
        sold_date: rawItems[0].sold_date || rawItems[0].export_date,
        all_keys: Object.keys(rawItems[0].toObject())
      });
    }
    
    // ‚úÖ FIX: Flexible field mapping ƒë·ªÉ support nhi·ªÅu field name kh√°c nhau  
    const items = rawItems.map(item => ({
      _id: item._id,
      sale_date: item.sold_date || item.createdAt,
      // ‚úÖ C·∫£i ti·∫øn mapping field gi√° b√°n - check nhi·ªÅu field
      sale_price: item.price_sell || item.giaBan || item.sale_price || 0,
      price_sell: item.price_sell || item.giaBan || 0, // Backup field
      buyer_name: item.customer_name || item.buyer_name || '',
      buyer_phone: item.customer_phone || item.buyer_phone || '',
      branch: item.branch || '',
      note: item.note || '',
      source: item.source || 'tien_mat',
      warranty: item.warranty || '',
      // ‚úÖ Th√™m c√°c field quan tr·ªçng kh√°c  
      price_import: item.price_import || item.giaNhap || 0,
      profit: (item.price_sell || item.giaBan || 0) - (item.price_import || item.giaNhap || 0),
      // ‚úÖ REMOVED: debt field - t√≠nh c√¥ng n·ª£ b·∫±ng price_sell - da_thanh_toan
      da_thanh_toan: item.da_thanh_toan || 0, // ‚úÖ TH√äM FIELD ƒê√É THANH TO√ÅN
      imei: item.imei || '',
      sku: item.sku || '',
      product_name: item.product_name || item.tenSanPham || '',
      customer_name: item.customer_name || '',
      customer_phone: item.customer_phone || '',
      item: {
        _id: item._id,
        product_name: item.product_name || item.tenSanPham,
        tenSanPham: item.tenSanPham || item.product_name,
        imei: item.imei || '',
        sku: item.sku || '',
        category: item.category || '',
      }
    }));
    
    res.status(200).json({ 
      message: '‚úÖ Danh s√°ch xu·∫•t h√†ng',
      total: items.length,
      items 
    });
  } catch (error) {
    console.error('‚ùå L·ªói API xuat-hang-list:', error);
    res.status(500).json({ message: '‚ùå L·ªói l·∫•y danh s√°ch xu·∫•t h√†ng', error: error.message });
  }
});

// API s·ª≠a xu·∫•t h√†ng - ƒê∆†N GI·∫¢N H√ìA THEO C√ÅCH NH·∫¨P H√ÄNG
app.put('/api/xuat-hang/:id', async (req, res) => {
  try {
    console.log('üîÑ PUT Request data:', req.body); // Debug
    console.log('üîç PUT Request ID:', req.params.id); // Debug
    console.log('üîç DEBUG da_thanh_toan in req.body:', req.body.da_thanh_toan); // Debug specific field

    // Ki·ªÉm tra record t·ªìn t·∫°i tr∆∞·ªõc khi c·∫≠p nh·∫≠t
    const existingRecord = await ExportHistory.findById(req.params.id);
    if (!existingRecord) {
      return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n xu·∫•t ƒë·ªÉ c·∫≠p nh·∫≠t.' });
    }

    console.log('üìã Existing record before update:', {
      _id: existingRecord._id,
      da_thanh_toan: existingRecord.da_thanh_toan,
      customer_name: existingRecord.customer_name
    });

    const updatedItem = await ExportHistory.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );

    console.log('‚úÖ Updated successfully:', {
      _id: updatedItem._id,
      da_thanh_toan: updatedItem.da_thanh_toan,
      price_sell: updatedItem.price_sell,
      customer_name: updatedItem.customer_name
    }); // Debug

    res.status(200).json({
      message: '‚úÖ C·∫≠p nh·∫≠t th√†nh c√¥ng!',
      item: updatedItem,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi c·∫≠p nh·∫≠t xu·∫•t h√†ng:', error.message);
    res.status(500).json({ message: '‚ùå L·ªói server khi c·∫≠p nh·∫≠t', error: error.message });
  }
});

app.delete('/api/xuat-hang/:id', async (req, res) => {
  try {
    // ‚úÖ X√≥a t·ª´ ExportHistory
    const exportRecord = await ExportHistory.findById(req.params.id);
    if (!exportRecord) {
      return res.status(404).json({ message: '‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n xu·∫•t h√†ng.' });
    }

    // N·∫øu c√≥ IMEI, kh√¥i ph·ª•c Inventory v·ªÅ in_stock
    if (exportRecord.imei) {
      const inventoryItem = await Inventory.findOne({ imei: exportRecord.imei });
      if (inventoryItem) {
        inventoryItem.status = 'in_stock';
        inventoryItem.sold_date = undefined;
        await inventoryItem.save();
      }
    }
    
    // N·∫øu l√† ph·ª• ki·ªán, tƒÉng l·∫°i s·ªë l∆∞·ª£ng trong Inventory
    if (!exportRecord.imei && exportRecord.sku) {
      const inventoryItem = await Inventory.findOne({ 
        sku: exportRecord.sku, 
        status: { $in: ['in_stock', 'sold'] }
      });
      if (inventoryItem) {
        inventoryItem.quantity = (inventoryItem.quantity || 0) + 1;
        inventoryItem.status = 'in_stock';
        await inventoryItem.save();
      }
    }

    // X√≥a record kh·ªèi ExportHistory
    await ExportHistory.findByIdAndDelete(req.params.id);

    res.status(200).json({ message: '‚úÖ ƒê√£ x√≥a ƒë∆°n xu·∫•t h√†ng v√† kh√¥i ph·ª•c t·ªìn kho!', item: exportRecord });
  } catch (error) {
    res.status(500).json({ message: '‚ùå L·ªói khi x√≥a ƒë∆°n xu·∫•t', error: error.message });
  }
});

// === API TR·∫¢ N·ª¢ NH√Ä CUNG C·∫§P (ghi chi v√†o s·ªï qu·ªπ) ===
app.post('/api/tra-no-ncc', async (req, res) => {
  try {
    const { supplier, amount, date, branch, source, note } = req.body;
    await Cashbook.create({
      type: 'chi',
      amount: Number(amount),
      content: `Tr·∫£ n·ª£ nh√† cung c·∫•p: ${supplier}`,
      note: note || '',
      date: date || new Date(),
      branch: branch || '',
      source: source || 'Ti·ªÅn m·∫∑t',
      supplier: supplier || ''
    });
    res.status(201).json({ message: '‚úÖ ƒê√£ ghi nh·∫≠n tr·∫£ n·ª£ nh√† cung c·∫•p!' });
  } catch (error) {
    res.status(500).json({ message: '‚ùå L·ªói khi ghi s·ªï tr·∫£ n·ª£', error: error.message });
  }
});

// === API THU N·ª¢ KH√ÅCH H√ÄNG (ghi thu v√†o s·ªï qu·ªπ) ===
app.post('/api/thu-no-khach', async (req, res) => {
  try {
    const { customer, amount, date, branch, source, note } = req.body;
    await Cashbook.create({
      type: 'thu',
      amount: Number(amount),
      content: `Thu n·ª£ kh√°ch: ${customer}`,
      note: note || '',
      date: date || new Date(),
      branch: branch || '',
      source: source || 'Ti·ªÅn m·∫∑t',
      customer: customer || ''
    });
    res.status(201).json({ message: '‚úÖ ƒê√£ ghi nh·∫≠n thu n·ª£ kh√°ch h√†ng!' });
  } catch (error) {
    res.status(500).json({ message: '‚ùå L·ªói khi ghi s·ªï thu n·ª£', error: error.message });
  }
});



mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/vphone')
.then(() => console.log('‚úÖ K·∫øt n·ªëi MongoDB th√†nh c√¥ng'))
.catch(err => console.error('‚ùå K·∫øt n·ªëi MongoDB l·ªói:', err));

app.get('/', (req, res) => {
  res.send('üéâ Backend ƒëang ch·∫°y!');
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => {
  console.log(`üöÄ Server ƒëang ch·∫°y t·∫°i http://localhost:${PORT}`);
});
